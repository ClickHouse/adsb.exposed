<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="icon" href="favicon.png">
    <title>ADS-B Massive Visualizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        :root {
            --progress: 0%;
            --progress-background-color1: #320;
            --progress-foreground-color1: #840;

            --progress-background-color2: #330;
            --progress-foreground-color2: #880;

            --progress-background-color3: #033;
            --progress-foreground-color3: #088;

            --progress-background-color-last: #333;
            --progress-foreground-color-last: #666;

            --progress-background-color: var(--progress-background-color4);
            --progress-foreground-color: var(--progress-foreground-color4);

            --report-width: 0%;
        }
        * {
            box-sizing: border-box;
        }

        html, body {
            background: #101213;
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            scrollbar-color: #333 black;
        }

        body {
            display: grid;
            grid-template-columns: auto var(--report-width);
            grid-template-rows: fit-content(2em) fit-content(2em) fit-content(10%) fit-content(2em) 1em auto;
            grid-gap: 0;
        }

        #proud {
            grid-column: span 2;
            font-family: sans-serif;
            font-size: 14pt;
            background: linear-gradient(
                90deg,
                white 0%,
                white 15%,
                yellow 50%,
                white 85%,
                white 100%
            );
            color: black;
            text-align: center;
            padding: 0.125em;
            text-decoration: none;
        }

        #proud:hover {
            background: linear-gradient(
                90deg,
                yellow 0%,
                yellow 15%,
                white 50%,
                yellow 85%,
                yellow 100%
            );
        }

        #query {
            grid-column: span 2;
            width: 100%;
            min-width: 100%;
            max-width: 100vw;
            height: 4.5em;
            max-height: 50vh;
            margin: 0;
            padding: .5em;
            outline: none;
            border: none;
            background: #101213;
            color: lightgray;
            font-size: 14pt;
            border-bottom: 1px #333 solid;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #111;
            image-rendering: pixelated;
        }

        .leaflet-fade-anim .leaflet-popup {
            transition: none;
            font-family: monospace;
        }

        .leaflet-control-attribution {
            font-size: 12pt;
        }

        #error {
            display: none;
            position: absolute;
            z-index: 1001;
            bottom: max(5%, 1em);
            left: 50%;
            transform: translate(-50%, 0);
            background: #300;
            color: white;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 16pt;
            padding: 1em;
            min-width: 50%;
            max-width: 80%;
        }

        #selection {
            display: none;
            position: absolute;
            z-index: 1001;
            border: 1px dashed white;
            backdrop-filter: brightness(150%);
            -webkit-backdrop-filter: brightness(150%); /* Safari */
        }

        #stats {
            grid-column: span 2;
            background: linear-gradient(to right,
                var(--progress-background-color) 0%,
                var(--progress-foreground-color) var(--progress),
                var(--progress-background-color) var(--progress));
            color: white;
            padding-right: .5em;
            font-family: monospace;
            text-align: right;
        }

        .choices {
            grid-column: span 2;
            background: #202020;
            color: white;
            font-size: 12pt;
            font-family: monospace;
            padding: .125em .5em;
        }

        .choices span {
            display: inline-block;
            padding: .25em .5em;
            background: #444;
            border: solid 0.125em black;
            user-select: none;
        }

        .choices span:hover, .choices span.selected:hover {
            color: black;
            background: yellow;
            cursor: pointer;
        }

        .choices span.selected {
            background: #FFF;
            color: #000;
        }

        #report {
            color: white;
            font-size: 12pt;
            font-family: monospace;
            background: #202020;
            padding: .5em;
            display: none;
            max-height: 100%;
            overflow-y: scroll;
        }

        #report div {
            margin-bottom: 1em;
            white-space: pre-wrap;
            color: lightgray;
        }

        #report a {
            color: white;
            border-bottom: 1px dashed #888;
            cursor: pointer;
        }

        #report a:hover {
            color: yellow;
            background: black;
            border-bottom: 1px dashed yellow;
            box-shadow: 0px 0px 10px rgba(0,0,0,1);
            font-weight: bold;
        }

        #picture {
            position: absolute;
            left: 1em;
            bottom: 4em;
            font-size: 16pt;
            z-index: 1001;
            display: none;
            box-shadow: 2px 2px 10px rgba(0,0,0,1);
            line-height: 0;
            min-width: 500px;
            min-height: 1em;
        }

        #picture-copyright {
            position: absolute;
            left: 0;
            bottom: 0;
            font-family: sans-serif;
            font-size: 12pt;
            line-height: 1;
            background: rgba(255, 255, 255, 0.5);
        }

        #picture-copyright a {
            text-decoration: none;
            color: #088;
        }

        #layers, #provider, #select {
            position: absolute;
            padding: .3em .5em .2em .5em;
            font-family: monospace;
            color: black;
            background: lightgray;
            box-shadow: 2px 2px 10px rgba(0,0,0,1);
            z-index: 1001;
            user-select: none;
        }

        #layers:hover, #provider:hover, #select:hover {
            filter: brightness(125%);
        }

        #layers {
            left: 1em;
            bottom: 1em;
            width: 2em;
            height: 2em;
            padding: .3em .5em .2em .5em;
            font-size: 16pt;
            text-align: center;
            cursor: pointer;
        }

        #select {
            left: 4em;
            bottom: 1em;
            width: 2em;
            height: 2em;
            padding: .3em .5em .2em .5em;
            font-size: 16pt;
            text-align: center;
            cursor: pointer;
        }

        #select img {
            padding-top: 13%;
            width: 120%;
        }

        #provider {
            right: 0.25em;
            bottom: 1.25em;
            height: 3em;
            padding: 0.1em .3em 0.1em 0.3em;
            font-size: 16pt;
        }

        #provider form {
            font-size: 12pt;
            color: #333;
        }

        #provider * {
            margin: 0;
            padding: 0;
        }
    </style>
</head>

<body>
    <a id="proud" href="https://github.com/ClickHouse/ClickHouse">Proudly made with <b>ClickHouse</b> open-source database</a>
    <div id="datasets" class="choices"></div>
    <textarea spellcheck="false" data-gramm="false" id="query"></textarea>
    <div id="examples" class="choices"></div>
    <div id="stats"></div>
    <div id="map"><div id="selection"></div></div>
    <div id="report"></div>
    <div id="picture"><img/><span id="picture-copyright">Picture from Wikipedia, &copy; the details at the corresponding page.</span></div>
    <div id="error"></div>
    <div id="layers">üëÅ</div>
    <div id="select"><img src="pointer.svg"/></div>

    <div id="provider"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="config.js"></script>
    <script>
        let uuid = crypto.randomUUID();

        let dataset;
        let config;
        let queries;
        let levels;

        let datasets_elem = document.getElementById('datasets');
        let examples_elem = document.getElementById('examples');
        let reports_elem = document.getElementById('report');
        let providers_elem = document.getElementById('provider');

        datasets_elem.append('Datasets: ');
        Object.keys(datasets).forEach((dataset_name, idx) => {
            let span = document.createElement('span');
            if (!idx) { span.className = 'selected'; }
            span.append(document.createTextNode(dataset_name));
            span.addEventListener('click', e => {
                for (other of document.querySelectorAll('#datasets span')) {
                    other.classList.remove('selected');
                }
                e.target.classList.add('selected');
                switchDataset(dataset_name);
            });
            datasets_elem.append(span);
        });

        function clearContainer(elem) {
            while (elem.firstChild) elem.removeChild(elem.firstChild);
        }

        function switchDataset(name) {
            dataset = name;
            config = datasets[dataset];
            queries = config.queries;
            levels = config.levels;

            clearContainer(examples_elem);
            clearContainer(reports_elem);
            clearContainer(providers_elem);

            for (other of datasets_elem.querySelectorAll('span')) {
                other.classList.remove('selected');
                if (dataset == other.innerText) {
                    other.classList.add('selected');
                }
            }

            examples_elem.append('Examples: ');
            Object.keys(queries).forEach((example, idx) => {
                let span = document.createElement('span');
                if (!idx) {
                    span.className = 'selected';
                    query_elem.value = queries[example];
                }
                span.append(document.createTextNode(example));
                span.addEventListener('click', e => {
                    for (other of examples_elem.querySelectorAll('.selected')) {
                        other.classList.remove('selected');
                    }
                    e.target.classList.add('selected');
                    setQuery(queries[example]);
                });
                examples_elem.append(span);
            });

            const report_total = document.createElement('div');
            report_total.id = 'report_total';
            reports_elem.append(report_total);

            config.reports.forEach(report => {
                let elem = document.createElement('div');
                elem.id = report.id;
                reports_elem.append(elem);
            });

            let form = document.createElement('form');
            config.endpoints.forEach((endpoint, idx) => {
                let label = document.createElement('label');
                let input = document.createElement('input');
                input.type = 'radio';
                input.name = 'provider';
                input.value = endpoint.name;
                if (!idx) { input.checked = true; } else { form.append(document.createElement('br')); }
                label.append(input);
                label.append(` ${endpoint.name}`);
                form.append(label);
            });
            form.addEventListener('change', e => {
                cached_tiles = {};
                updateMap();
            });

            providers_elem.append(form);
            providers_elem.style.display = config.endpoints.length > 1 ? 'block' : 'none';

            const layer_options = {
                tileSize: 1024,
                minZoom: 2,
                maxZoom: 19,
                minNativeZoom: 2,
                maxNativeZoom: 16,
                attribution: `¬© Alexey Milovidov, ClickHouse, Inc. (data: ${config.notice})`
            };

            layers.forEach(layer => layer.removeFrom(map));
            layers = [];

            levels.forEach((level, idx) => {
                let options = layer_options;
                options.level = level;
                layers.push(new L.GridLayer.ClickHouse(options));
            });

            layers[0].addTo(map);
            layers[0].on('loading', e => {
                layers.forEach((layer, idx) => {
                    if (idx) { layer.removeFrom(map); }
                });
                document.documentElement.style.setProperty('--progress-background-color', 'var(--progress-background-color1)');
                document.documentElement.style.setProperty('--progress-foreground-color', 'var(--progress-foreground-color1)');
            });

            /// Sequential loading for different levels of details

            layers.forEach((layer, idx) => {
                layer.on('load', e => {
                    if (idx + 1 < layers.length) {
                        layers[idx + 1].addTo(map);
                        document.documentElement.style.setProperty('--progress-background-color', `var(--progress-background-color${idx + 2})`);
                        document.documentElement.style.setProperty('--progress-foreground-color', `var(--progress-foreground-color${idx + 2})`);
                    } else {
                        document.documentElement.style.setProperty('--progress-background-color', `var(--progress-background-color-last`);
                        document.documentElement.style.setProperty('--progress-foreground-color', `var(--progress-foreground-color-last`);
                        document.documentElement.style.setProperty('--progress', '0');
                    }
                });
            });

            cached_tiles = {};
            updateMap();
        }

        let base_layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            zoomOffset: 0,
            minZoom: 2,
            maxZoom: 19,
            attribution: '¬© OpenStreetMap',
            opacity: 0.1,
        });

        let layers = [];

        let map = L.map('map', {
            center: [52.3676, 4.9041],
            zoom: 5,
            worldCopyJump: true,
            layers: [base_layer]
        });

        map.attributionControl.setPrefix('<a href="https://github.com/ClickHouse/adsb.exposed/">About</a>');

        let query_elem = document.getElementById('query');
        let map_elem = document.getElementById('map');
        let selected_box = [];
        let cached_tiles = {};

        /// Protect from race conditions.
        let report_sequence_num = 0;

        /// Query editor

        function expandQueryEditor() {
            query_elem.style.height = query_elem.scrollHeight + 'px';
        }

        function collapseQueryEditor() {
            query_elem.style.height = '4.5em';
            query_elem.blur();
        }

        function updateMap() {
            let selected_example = examples_elem.querySelector('.selected');
            if (selected_example && query_elem.value != queries[selected_example.textContent]) {
                selected_example.classList.remove('selected');
            }

            layers[0]?.redraw();
            if (selected_box.length == 2) showReport();
        }

        function setQuery(value) {
            query_elem.value = value;
            collapseQueryEditor();
            updateMap();
            updateHistory();
        }

        query_elem.addEventListener('input', expandQueryEditor);
        query_elem.addEventListener('focus', expandQueryEditor);
        query_elem.addEventListener('blur', updateMap);
        map_elem.addEventListener('focus', collapseQueryEditor);

        query_elem.addEventListener('keydown', e => {
            /// Firefox has code 13 for Enter and Chromium has code 10.
            if ((event.metaKey || event.ctrlKey) && (event.keyCode == 13 || event.keyCode == 10)) {
                collapseQueryEditor();
                updateMap();
            }
        });

        function getHosts(stick) {
            const provider = providers_elem.querySelector('input[name="provider"]:checked').value;

            return config.endpoints.find(endpoint => endpoint.name == provider).urls.map(url => {
                if (stick && url.sticky) {
                    const hash = sipHash128(JSON.stringify(stick)).substr(0, 3);
                    return url.sticky.replace('{hash}', hash);
                } else {
                    return url.url;
                }
            });
        }

        class CustomError extends Error {
            constructor(message, payload) {
                super(message);
                this.name = this.constructor.name;
                this.payload = payload;
            }
        }

        /// Returns the first successful (HTTP 2xx) response or an error if all of them failed.
        /// Cancels other requests on first success.
        function fetchAny(urls, params) {
            const abort_controllers = {};
            urls.forEach(url => abort_controllers[url] = new AbortController);

            const requests = urls.map(url => {
                const abort_controller = abort_controllers[url];
                params.signal = abort_controller.signal;
                return fetch(url, params).then(response => {
                    if (response.ok) {
                        urls.filter(other => other != url).map(other => abort_controllers[other].abort());
                        return response;
                    }
                    throw new CustomError(response.statusText, response);
                }).catch(error => {
                    return Promise.reject(error);
                })
            });

            return Promise.any(requests);
        }

        /// Rendering

        let progress_update_period = null;
        let query_sequence_num = 0;

        async function render(level, coords, tile) {
            const sql = query_elem.value;
            const key = `${sipHash128(sql)}-${coords.z}-${coords.x}-${coords.y}`;

            if (!cached_tiles[key]) cached_tiles[key] = [];

            buf = cached_tiles[key][level.priority];

            if (!buf) {
                ++query_sequence_num;
                const query_id = `${uuid}-${query_sequence_num}-${level.table}-${coords.z - 2}-${coords.x}-${coords.y}`;
                const hosts = getHosts(key);
                const url = host => `${host}/?user=website&default_format=RowBinary` +
                    `&query_id=${query_id}&replace_running_query=1` +
                    `&param_table=${level.table}&param_sampling=${level.sample}` +
                    `&param_z=${coords.z - 2}&param_x=${coords.x}&param_y=${coords.y}`;

                progress_update_period = 1;

                try {
                    const response = await fetchAny(hosts.map(host => url(host)), { method: 'POST', body: sql });
                    buf = await response.arrayBuffer();
                    if (!cached_tiles[key]) cached_tiles[key] = [];
                    cached_tiles[key][level.priority] = buf;
                } catch (error) {
                    let text;
                    if (error.errors) {
                        const response = error.errors[0].payload;
                        text = await response.text();
                    } else {
                        console.log(error);
                        text = error.toString();
                    }
                    if (!text.includes('QUERY_WAS_CANCELLED') &&
                        !text.includes('QUERY_WITH_SAME_ID_IS_ALREADY_RUNNING')) {
                        let err = document.getElementById('error');
                        err.textContent = text;
                        err.style.display = 'block';
                    }
                    return;
                }
            }

            let ctx = tile.getContext('2d');
            let image = ctx.createImageData(1024, 1024, {colorSpace: 'display-p3'});
            let arr = new Uint8ClampedArray(buf);

            for (let i = 0; i < 1024 * 1024 * 4; ++i) { image.data[i] = arr[i]; }

            ctx.putImageData(image, 0, 0, 0, 0, 1024, 1024);

            let err = document.getElementById('error');
            err.style.display = 'none';
        }

        L.GridLayer.ClickHouse = L.GridLayer.extend({
            createTile: function(coords, done) {
                let tile = L.DomUtil.create('canvas', 'leaflet-tile');
                tile.width = 1024;
                tile.height = 1024;
                render(this.options.level, coords, tile).then(err => done(err, tile));
                return tile;
            }
        });

        switchDataset('Planes');

        /// Restore from a saved link

        function latlngToMercator(latlng) {
            return {
                x: Math.round(0xFFFFFFFF * ((latlng.lng + 180) / 360)),
                y: Math.round(0xFFFFFFFF * (1/2 - Math.log(Math.tan((latlng.lat + 90) / 360 * Math.PI)) / 2 / Math.PI)),
                lat: latlng.lat,
                lng: latlng.lng
            };
        }

        let initial_load = true;

        if (window.location.search) {
            const params = new URLSearchParams(window.location.search);
            const params_dataset = params.get('dataset');
            if (params_dataset && params_dataset != dataset) {
                switchDataset(params_dataset);
            }
            const hash = params.get('query');
            if (hash) {
                loadQuery(hash).then(query => {
                    query_elem.value = query;
                    map.setView({lat: params.get('lat'), lng: params.get('lng')}, params.get('zoom'));
                    updateMap();

                    for (example of examples_elem.querySelectorAll('span')) {
                        example.classList.remove('selected');
                        if (query == queries[example.innerText]) {
                            example.classList.add('selected');
                        }
                    }
                });
            } else {
                map.setView({lat: params.get('lat'), lng: params.get('lng')}, params.get('zoom'));
            }
            const box = params.get('box');
            if (box) {
                const arr = box.split(',');
                selected_box = [latlngToMercator({lat: +arr[0], lng: +arr[1]}), latlngToMercator({lat: +arr[2], lng: +arr[3]})];
                showReport();
            }
        } else {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    map.setView([position.coords.latitude, position.coords.longitude]);
                });
            }
        }

        /// Rectangle selection and reports

        let select_toggle = document.getElementById('select');
        let select_toggle_active = false;

        select_toggle.addEventListener('click', e => {
            select_toggle_active = !select_toggle_active;
            select_toggle.style.backgroundColor = select_toggle_active ? 'yellow' : '';

            if (select_toggle_active) {
                map.dragging.disable();
                map_elem.style.cursor = 'crosshair';
            } else {
                map.dragging.enable();
                map_elem.style.cursor = '';
                hideSelection();
                hideReport();
            }
        });

        let selecting = false;
        let selection_origin_point = {x: 0, y: 0};
        let selection = document.getElementById('selection');

        function showReport() {
            ++report_sequence_num;
            const current_report_sequence_num = report_sequence_num;

            for (node of document.getElementById('report').childNodes) { node.textContent = '' };
            document.getElementById('report').style.display = 'block';
            document.documentElement.style.setProperty('--report-width', 'fit-content(20%)');

            const current_query = query_elem.value;

            /// This is fairly dirty.
            const condition = /WHERE(.+)GROUP BY/is.exec(current_query)[1];

            async function calculateReport(sql, field) {
                const query_id = `${uuid}-${field}-${current_report_sequence_num}`;
                const hosts = getHosts([field, selected_box, sql]);
                const url = host => `${host}/?user=website&default_format=JSON&query_id=${query_id}` +
                    `&param_table=${levels[levels.length - 1].table}` +
                    `&param_left=${Math.min(selected_box[0].x, selected_box[1].x)}` +
                    `&param_right=${Math.max(selected_box[0].x, selected_box[1].x)}` +
                    `&param_top=${Math.min(selected_box[0].y, selected_box[1].y)}` +
                    `&param_bottom=${Math.max(selected_box[0].y, selected_box[1].y)}`;

                progress_update_period = 1;
                const response = await fetchAny(hosts.map(host => url(host)), { method: 'POST', body: sql });

                if (!response.ok) {
                    const text = await response.text();
                    if (!text.includes('QUERY_WAS_CANCELLED') && !text.includes('QUERY_WITH_SAME_ID_IS_ALREADY_RUNNING')) {
                        let err = document.getElementById('error');
                        err.textContent = text;
                        err.style.display = 'block';
                    }
                    return;
                }

                const json = await response.json();
                return json;
            }

            async function findPicture(name) {
                const wiki_api_url = 'https://en.wikipedia.org/w/api.php';

                const search_url = wiki_api_url + '?' + new URLSearchParams({
                    action: 'query',
                    list: 'search',
                    srsearch: name,
                    format: 'json',
                    origin: '*'
                });

                const response = await fetch(search_url);
                const search_data = await response.json();

                if (search_data.query && search_data.query.search && search_data.query.search.length > 0) {
                    const title = search_data.query.search[0].title;

                    const page_url = wiki_api_url + '?' + new URLSearchParams({
                        action: 'query',
                        titles: title,
                        prop: 'pageimages',
                        format: 'json',
                        origin: '*'
                    });

                    const response = await fetch(page_url);
                    const pages_data = await response.json();

                    const pages = pages_data.query.pages;
                    const page_id = Object.keys(pages)[0];
                    if (pages[page_id].thumbnail) {

                        const image_info_url = wiki_api_url + '?' + new URLSearchParams({
                            action: 'query',
                            titles: 'File:' + pages[page_id].pageimage,
                            prop: 'imageinfo',
                            iiprop: 'extmetadata',
                            format: 'json',
                            origin: '*'
                        });

                        const image_info_response = await fetch(image_info_url);
                        const image_info_data = await image_info_response.json();

                        const metadata = Object.values(image_info_data.query.pages)[0].imageinfo[0].extmetadata;
                        const attribution = `${metadata.LicenseShortName.value}, ${metadata.Artist.value}`;

                        return {src: pages[page_id].thumbnail.source.replace(/\/\d+px/, '/500px'), attr: attribution};
                    }
                }
            }

            let cached_pictures = {};
            async function findPictureCached(name) {
                if (cached_pictures[name]) return cached_pictures[name];
                const result = await findPicture(name);
                cached_pictures[name] = result;
                return result;
            }

            function createList(sql, field, elem_id, title, separator, link_content_func, wiki_field) {
                calculateReport(sql, field).then(json => {
                    if (current_report_sequence_num != report_sequence_num) return;

                    let elem = document.getElementById(elem_id);
                    clearContainer(elem);
                    elem.appendChild(document.createTextNode(title));
                    for (const [idx, row] of json.data.entries()) {
                        if (idx) {
                            let comma = document.createTextNode(separator);
                            elem.appendChild(comma);
                        }
                        let link = document.createElement('a');
                        link.textContent = link_content_func(row);
                        link.addEventListener('click', e => {
                            let sql_value = row[field].replace('\\', '\\\\').replace('\'', '\\\'');
                            let condition = `${field} = '${sql_value}'`;
                            let changed_query = current_query.replace(
                                /(WHERE.+?)(\/\* Filter: \*\/ AND .+)?(GROUP BY)/is,
                                '$1' + '/* Filter: */ AND ' + condition + '\n$3');

                            setQuery(changed_query);
                        });

                        /// Pictures from Wikipedia
                        if (wiki_field) {
                            link.addEventListener('mouseover', e => {
                                findPictureCached(row[wiki_field]).then(data => {
                                    if (data) {
                                        let picture = document.getElementById('picture');
                                        picture.style.display = 'block';
                                        picture.firstChild.src = data.src;
                                        let copyright = document.getElementById('picture-copyright');
                                        copyright.innerHTML = data.attr;
                                        /// Sometimes there are tables, paragraphs, etc. Strip them.
                                        copyright.innerHTML = copyright.innerText;
                                    }
                                });
                            });
                            link.addEventListener('mouseout', e => {
                                let picture = document.getElementById('picture');
                                picture.style.display = 'none';
                                picture.firstChild.src = '';
                            });
                        }

                        elem.appendChild(link);
                    }
                    if (json.data.length >= 100) elem.appendChild(document.createTextNode('‚Ä¶'));
                });
            }

            calculateReport(config.report_total.query(condition)).then(json => {
                document.getElementById('report_total').textContent = config.report_total.content(json);
            });

            config.reports.forEach(report => {
                createList(report.query(condition), report.field, report.id, report.title, report.separator, report.content, report.wiki_field ?? null);
            });
        }

        function hideReport() {
            selected_box = [];
            document.getElementById('report').style.display = 'none';
            document.documentElement.style.setProperty('--report-width', '0%');
            let picture = document.getElementById('picture');
            picture.style.display = 'none';
            picture.firstChild.src = '';
        }

        function hideSelection() {
            selection.style.display = 'none';
            hideReport();
        }

        map.on('contextmenu', e => {
            return false;
        });

        function selectStart(e) {
            if (e.button !== 2 && !select_toggle_active) return;

            const rect = map_elem.getBoundingClientRect();
            const x = e.clientX - rect.x;
            const y = e.clientY - rect.y;

            selection_origin_point.x = Math.round(x);
            selection_origin_point.y = Math.round(y);

            selected_box[0] = latlngToMercator(map.containerPointToLatLng([x, y]));

            selection.style.display = 'block';
            selection.style.left = selection_origin_point.x + 'px';
            selection.style.top = selection_origin_point.y + 'px';
            selection.style.width = 0;
            selection.style.height = 0;
            selecting = true;

            e.preventDefault();
        }

        map_elem.addEventListener('pointerdown', selectStart);
        /// https://www.redblobgames.com/making-of/draggable/
        map_elem.addEventListener('touchstart', e => e.preventDefault());

        function selectMove(e) {
            if (!selecting) return;

            const rect = map_elem.getBoundingClientRect();
            const x = e.clientX - rect.x;
            const y = e.clientY - rect.y;

            if (x >= selection_origin_point.x) {
                selection.style.width = Math.round(x - selection_origin_point.x) + 'px';
            } else {
                selection.style.left = Math.round(x) + 'px';
                selection.style.width = Math.round(selection_origin_point.x - x) + 'px';
            }

            if (y >= selection_origin_point.y) {
                selection.style.height = Math.round(y - selection_origin_point.y) + 'px';
            } else {
                selection.style.top = Math.round(y) + 'px';
                selection.style.height = Math.round(selection_origin_point.y - y) + 'px';
            }

            e.preventDefault();
        };

        map_elem.addEventListener('pointermove', selectMove);

        function selectStop(e) {
            if ((e.button !== 2 && !select_toggle_active) || !selecting) return;
            selecting = false;

            const rect = map_elem.getBoundingClientRect();
            const x = e.clientX - rect.x;
            const y = e.clientY - rect.y;

            if (selection_origin_point.x == Math.round(x) &&
                selection_origin_point.y == Math.round(y)) {
                hideSelection();
            } else {
                selected_box[1] = latlngToMercator(map.containerPointToLatLng([x, y]));
                showReport();
                updateHistory();
            }

            e.preventDefault();
        };

        map_elem.addEventListener('pointerup', selectStop);
        map_elem.addEventListener('pointercancel', selectStop);

        /// Progress bar

        const progress_min_interval = 100;
        let progress_update_counter = 0;
        let previous_progress_update = 0;

        async function getStats() {
            ++progress_update_counter;
            if (!progress_update_period || (progress_update_counter - previous_progress_update) < progress_update_period) {
                setTimeout(getStats, progress_min_interval);
                return;
            }

            const sql = `SELECT
                    sum(read_rows) AS r,
                    sum(total_rows_approx) AS t,
                    sum(read_bytes) AS b,
                    r / max(elapsed) AS rps,
                    b / max(elapsed) AS bps,
                    formatReadableQuantity(r) AS formatted_rows,
                    formatReadableSize(b) AS formatted_bytes,
                    formatReadableQuantity(rps) AS formatted_rps,
                    formatReadableSize(bps) AS formatted_bps
                FROM clusterAllReplicas(default, system.processes)
                WHERE user = 'website' AND startsWith(query_id, {uuid:String})`;

            const hosts = getHosts(uuid);
            const url = host => `${host}/?user=website_progress&default_format=JSON&skip_unavailable_shards=1&param_uuid=${uuid}`;

            let responses = await Promise.all(hosts.map(host => fetch(url(host), { method: 'POST', body: sql })));
            let datas = await Promise.all(responses.map(response => response.json()));

            /// Which of the hosts are processing our queries?
            const stat = datas.map(d => d.data[0]).filter(d => d.t && d.t > 0).sort((a, b) => b.bps - a.bps)[0];

            if (stat) {
                document.documentElement.style.setProperty('--progress', (100 * stat.r / stat.t) + '%');

                let text = '';
                if (stat.r > 0) text += `Processed ${stat.formatted_rows} rows, ${stat.formatted_bytes}`;
                if (stat.rps > 100e6) text += ` (${stat.formatted_rps}/sec, ${stat.formatted_bps}/sec)`;

                document.getElementById('stats').textContent = text;
                progress_update_period = 1;
            } else {
                document.documentElement.style.setProperty('--progress', '0');
                progress_update_period *= 2;
            }

            previous_progress_update = progress_update_counter;
            setTimeout(getStats, progress_min_interval);
        }

        setTimeout(getStats, progress_min_interval);

        /// Saved queries

        function sipHash128(text) {
            const m = (new TextEncoder).encode(text);

            function rotl(v, offset, bits) {
                v[offset] = (v[offset] << bits) | (v[offset] >> (64n - bits));
            }

            function compress(v) {
                v[0] += v[1];
                v[2] += v[3];
                rotl(v, 1, 13n);
                rotl(v, 3, 16n);
                v[1] ^= v[0];
                v[3] ^= v[2];
                rotl(v, 0, 32n);
                v[2] += v[1];
                v[0] += v[3];
                rotl(v, 1, 17n);
                rotl(v, 3, 21n);
                v[1] ^= v[2];
                v[3] ^= v[0];
                rotl(v, 2, 32n);
            }

            const view = new DataView(m.buffer);
            let buf = new Uint8Array(new ArrayBuffer(8));
            let v = new BigUint64Array([0x736f6d6570736575n, 0x646f72616e646f6dn, 0x6c7967656e657261n, 0x7465646279746573n]);

            let offset = 0;
            for (; offset < m.length - 7; offset += 8) {
                let word = view.getBigUint64(offset, true);
                v[3] ^= word;
                compress(v);
                compress(v);
                v[0] ^= word;
            }

            buf.set(m.slice(offset));
            buf.fill(0, m.length - offset, 7);
            buf[7] = m.length;

            let word = new DataView(buf.buffer).getBigUint64(0, true);

            v[3] ^= word;
            compress(v);
            compress(v);
            v[0] ^= word;
            v[2] ^= 0xFFn;
            compress(v);
            compress(v);
            compress(v);
            compress(v);

            return ('00000000000000000000000000000000' + ((v[0] ^ v[1]) + ((v[2] ^ v[3]) << 64n)).toString(16)).substr(-32).
                match(/../g).reverse().join('');
        }

        async function saveQuery(text) {
            const sql = `INSERT INTO saved_queries (text) FORMAT RawBLOB`;
            const hosts = getHosts(null);
            const url = host => `${host}/?user=website_saved_queries&query=${encodeURIComponent(sql)}`;
            const response = await Promise.all(hosts.map(host => fetch(url(host), { method: 'POST', body: text })));
        }

        async function loadQuery(hash) {
            const sql = `SELECT text FROM saved_queries WHERE hash = unhex({hash:String}) LIMIT 1`;
            const hosts = getHosts(null);
            const url = host => `${host}/?user=website_saved_queries&default_format=JSON&param_hash=${hash}`;
            const response = await fetchAny(hosts.map(host => url(host)), { method: 'POST', body: sql });
            const data = await response.json();
            return data.data[0].text;
        }

        /// Layers visibility toggle

        document.getElementById('layers').addEventListener('click', e => {
            const mode = base_layer.options.opacity < 0.5;

            if (mode) {
                base_layer.setOpacity(0.5);
                base_layer.bringToFront();
            } else {
                base_layer.setOpacity(0.1);
                base_layer.bringToBack();
            }
        });

        /// History support

        function updateHistory() {
            const text = query_elem.value;
            saveQuery(text);
            const query_hash = sipHash128(text);

            const state = {
                dataset: dataset,
                zoom: map.getZoom(),
                center: map.getCenter(),
                query: text,
                box: selected_box,
            };

            let search = `?dataset=${dataset}&zoom=${state.zoom}&lat=${state.center.lat.toFixed(4)}&lng=${state.center.lng.toFixed(4)}&query=${query_hash}`;
            if (selected_box.length == 2) {
                search += `&box=${selected_box[0].lat.toFixed(4)},${selected_box[0].lng.toFixed(4)},${selected_box[1].lat.toFixed(4)},${selected_box[1].lng.toFixed(4)}`;
            }
            history.replaceState(state, '', search);
        }

        window.onpopstate = function(event) {
            const state = event.state;
            if (!state) return;
            if (state.dataset && state.dataset != dataset) {
                switchDataset(state.dataset);
            }
            query_elem.value = state.query;
            map.setView(state.center, state.zoom);
            if (state.box.length == 2) {
                selected_box = state.box;
                showReport();
            }
        };

        map.on('movestart', e => {
            selection.style.display = 'none';
        });
        map.on('moveend', e => {
            if (!initial_load) {
                updateHistory();
            } else {
                initial_load = false;
            }

            if (selected_box && selected_box.length == 2) {
                const point0 = map.latLngToContainerPoint([selected_box[0].lat, selected_box[0].lng]);
                const point1 = map.latLngToContainerPoint([selected_box[1].lat, selected_box[1].lng]);

                selection.style.display = 'block';
                selection.style.left = point0.x + 'px';
                selection.style.top = point0.y + 'px';
                selection.style.width = (point1.x - point0.x) + 'px';
                selection.style.height = (point1.y - point0.y) + 'px';
            }
        });
    </script>
</body>
</html>
